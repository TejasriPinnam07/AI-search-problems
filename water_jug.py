# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BzJIl6-c4opOEtHEfq6-S1KcgjUVZ3rB
"""

import time
from IPython.display import clear_output

# ANSI escape codes for colors
RESET = "\033[0m"
BLUE = "\033[44m"  # Blue background
WHITE = "\033[47m"  # White background
RED = "\033[41m"    # Red background
GREEN = "\033[42m"  # Green background
BOLD = "\033[1m"

def display_state_colored(jug1, jug2, max1, max2, countdown, step_desc, steps_log):
    """
    Function to visually display the current water levels in the jugs and the bomb's status using colored ASCII art.
    """
    clear_output(wait=True)

    def generate_jug_colored(water, capacity):
        """Generate colored ASCII art for a jug with given water level."""
        jug = []
        for level in range(capacity, 0, -1):
            if level <= water:
                jug.append(f"|{BLUE}    {RESET}|")  # Filled level
            else:
                jug.append(f"|{WHITE}    {RESET}|")  # Empty level
        jug.append("+----+")  # Jug base
        return "\n".join(jug)

    def generate_bomb_colored(countdown):
        """Generate colored ASCII art for the bomb and countdown bar."""
        bomb_face = f"{BOLD}O_O{RESET}" if countdown > 0 else f"{BOLD}-_-{RESET}"
        bomb_status = f"{GREEN}DEFUSED{RESET}" if countdown <= 0 else f"{RED}TICKING{RESET}"

        # Countdown bar
        bar_length = 20  # Max length of the progress bar
        filled_length = int((countdown / 10) * bar_length)
        bar = f"{GREEN}{'#' * filled_length}{RESET}{'-' * (bar_length - filled_length)}"

        bomb = f"""
         ,======.
        |  {bomb_face}  |
        |        |
         `======''
        [{bar}]
        Countdown: {countdown}s
        """
        return bomb

    # Generate visualizations
    jug1_art = generate_jug_colored(jug1, max1)
    jug2_art = generate_jug_colored(jug2, max2)
    bomb_art = generate_bomb_colored(countdown)

    # Display the current state
    print(f"Step: {step_desc}\n")
    print(f"Jug 1:\n{jug1_art}\n")
    print(f"Jug 2:\n{jug2_art}\n")
    print(f"Bomb:\n{bomb_art}\n")

    # Display all previous steps below the animation
    print("Steps Log:")
    for log in steps_log:
        print(log)

    time.sleep(0.7)

def gcd(a, b):
    """Helper function to compute the greatest common divisor."""
    while b:
        a, b = b, a % b
    return a

def water_jug_solver_with_animation(max1, max2, target, countdown):
    """
    Solve the water jug problem with animated visualization and persistent commentary.
    """
    if target % gcd(max1, max2) != 0:
        print("Impossible to measure the target amount with the given jug sizes.")
        return []

    visited = set()
    queue = [(0, 0, countdown, "Start: Both jugs are empty.")]
    path = []
    steps_log = []  # To track and display all steps

    while queue:
        jug1, jug2, timer, desc = queue.pop(0)

        # Check if the bomb timer has run out
        if timer <= 0:
            steps_log.append("BOOM! The bomb exploded.")
            display_state_colored(jug1, jug2, max1, max2, 0, "Bomb exploded!", steps_log)
            print("BOOM! The bomb exploded.")
            return []

        if (jug1, jug2) in visited:
            continue
        visited.add((jug1, jug2))
        path.append((jug1, jug2, timer, desc))

        # Add the step description to the log
        steps_log.append(f"{desc} | Jug 1: {jug1}L, Jug 2: {jug2}L | Countdown: {timer}s")

        # Check if we've reached the target amount
        if jug1 == target or jug2 == target:
            steps_log.append("Target achieved! Bomb defused.")
            display_state_colored(jug1, jug2, max1, max2, timer, "Target achieved! Bomb defused.", steps_log)
            return path

        # Generate all possible states
        transitions = [
            (max1, jug2, timer - 1, "Filled Jug 1 to its maximum capacity."),
            (jug1, max2, timer - 1, "Filled Jug 2 to its maximum capacity."),
            (0, jug2, timer - 1, "Emptied Jug 1 completely."),
            (jug1, 0, timer - 1, "Emptied Jug 2 completely."),
            (jug1 - min(jug1, max2 - jug2), jug2 + min(jug1, max2 - jug2), timer - 1, "Poured water from Jug 1 into Jug 2."),
            (jug1 + min(jug2, max1 - jug1), jug2 - min(jug2, max1 - jug1), timer - 1, "Poured water from Jug 2 into Jug 1.")
        ]

        for state in transitions:
            if state[:2] not in visited:
                queue.append(state)

        # Display the current state
        display_state_colored(jug1, jug2, max1, max2, timer, desc, steps_log)

    steps_log.append("No solution found. The bomb exploded!")
    display_state_colored(0, 0, max1, max2, 0, "No solution found. The bomb exploded!", steps_log)
    return []

def main():
    max1 = int(input("Enter capacity of Jug 1: "))
    max2 = int(input("Enter capacity of Jug 2: "))
    target = int(input("Enter target amount of water: "))
    countdown = int(input("Enter bomb countdown timer (in seconds): "))

    path = water_jug_solver_with_animation(max1, max2, target, countdown)
    if not path:
        return

    print("\nAll steps completed.")

if __name__ == "__main__":
    main()